/*------------------------------------------------------------------------*/
/* Copyright (C) 2020, Daniela Kaufmann, Johannes Kepler University Linz    */
/*------------------------------------------------------------------------*/
#define VERSION "001"

static const char * usage =
"pacheck [ <option> ... ]  [ <polynomials> <proof>] [<spec>]\n"
"\n"
"where <option> is one of the following\n"
"\n"
"  -h | --help            print this command line option summary and exit\n"
"\n"
"  -s | --no-target       only check inferences but not that proof generates target\n"
"\n"
"  -v | --verbose         get verbose output on number of checked inferences (beep every 500 rules)\n"
"\n"
"  -e | --use-exponents   turn off implicit reduction of exponents\n"
"\n"
"  -i | --no-indices      turn off usage of indices \n"
"\n"
"  -d | --no-delete       ignore delete rules\n"
"\n"
"  -s1                    sort variables according to -1*strcmp (default strcmp)\n"
"  -s2                    sort variables according to input order\n"
"  -s3                    sort variables according to reverse input order\n"
"\n"
"  --print        print polynomials in failing checks for better diagnosis\n"
"\n"
"  --sparse       use spaces to make printed polynomials easier to read\n"
"\n"
"The <polynomials> argument should point to a file with the\n"
"original set of polynomials and <proof> is a path to a proof file\n"
"interpreted as a sequence of inferences in the polynomial calculus.\n"
"The tool checks that all inferences in the sequence are correct.\n"
"\n"
"The <spec> is optional. Ommiting this file has the same effect as choosing option '-s'\n"
"It should point to a file with a single polynomial which\n"
"should be generated by the proof.\n"
"The exit code is zero if and only if all checks succeed.\n"
;

/*------------------------------------------------------------------------*/

#include <assert.h>
#include <ctype.h>
#include <inttypes.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <gmp.h>

#ifdef HAVEGETRUSAGE
#include <sys/time.h>
#include <sys/resource.h>
#endif
/*------------------------------------------------------------------------*/
static int check_target = 1;
static int check_count = 0;
static int exponents = 0;
static int delete_mode = 1;
static int indices = 1;

static int sort = 0;
static int add_new = 1;
// error and verbose messages

static void die (const char * msg, ...) {
  fflush (stdout);
  fprintf (stderr, "*** 'pacheck' error: ");
  va_list ap;
  va_start (ap, msg);
  vfprintf (stderr, msg, ap);
  va_end (ap);
  fprintf (stderr, "\n");
  fflush (stderr);
  exit (1);
}

static void msg (const char * msg, ...) {
  fprintf (stdout, "[pacheck] ");
  va_list ap;
  va_start (ap, msg);
  vfprintf (stdout, msg, ap);
  va_end (ap);
  fprintf (stdout, "\n");
  fflush (stdout);
}

/*------------------------------------------------------------------------*/

// memory management routines maintaining a count of allocated memory

static size_t current_allocated_bytes;
static size_t max_allocated_bytes;

static void inc_allocated_bytes (size_t bytes) {
  current_allocated_bytes += bytes;
  if (current_allocated_bytes > max_allocated_bytes)
    max_allocated_bytes = current_allocated_bytes;
}

static void dec_allocated_bytes (size_t bytes) {
  assert (current_allocated_bytes >= bytes);
  current_allocated_bytes -= bytes;
}

static void * allocate (size_t bytes) {
  if (!bytes) return 0;
  void * res = malloc (bytes);
  if (bytes) {
    if (res) memset (res, 0, bytes);
    else die ("out-of-memory allocating %zu bytes", bytes);
  }
  inc_allocated_bytes (bytes);
  return res;
}

static void deallocate (void * ptr, size_t bytes) {
  dec_allocated_bytes (bytes);
  free (ptr);
}

static void * reallocate (void * ptr, size_t old_bytes, size_t new_bytes) {
  dec_allocated_bytes (old_bytes);
  void * res = realloc (ptr, new_bytes);
  if (res) {
    if (new_bytes > old_bytes)
      memset (res + old_bytes, 0, new_bytes - old_bytes);
  } else die ("out-of-memory reallocating %zu bytes", new_bytes);
  inc_allocated_bytes (new_bytes);
  return res;
}

/*------------------------------------------------------------------------*/

// 'polymorphic' array management routine maintain a count of allocated memory

#define ALLOCATE(P,N) \
do { \
  size_t BYTES = (N) * sizeof *(P); \
  (P) = allocate (BYTES); \
} while (0)

#define DEALLOCATE(P,N) \
do { \
  size_t BYTES = (N) * sizeof *(P); \
  deallocate ((P), BYTES); \
} while (0)

#define REALLOCATE(P,O,N) \
do { \
  size_t OLD_BYTES = (O) * sizeof *(P); \
  size_t NEW_BYTES = (N) * sizeof *(P); \
  (P) = reallocate ((P), OLD_BYTES, NEW_BYTES); \
} while (0)

/*------------------------------------------------------------------------*/

// some smaller helper macros

#define SWAP(TYPE,A,B) \
do { \
  TYPE TMP = (A); \
  (A) = (B); \
  (B) = TMP; \
} while (0)

#define MAX(A,B) \
  ((A) < (B) ? (B) : (A))

/*------------------------------------------------------------------------*/

// Random odd 64 numbers for constructing hash functions.

static uint64_t nonces[32];
static const size_t num_nonces = sizeof nonces / sizeof nonces[0];

static uint16_t rand16 () {
  int tmp = rand ();
  assert (tmp >= 0);
  uint16_t res = tmp ^ (tmp >> 16);
  return res;
}

static uint64_t rand64 () {
  uint64_t res = 0;
  for (unsigned i = 0; i < 64; i += 16)
    res |= rand16 () << i;
  return res;
}

static void init_nonces () {
  srand (42);
  for (size_t i = 0; i < num_nonces; i++)
    nonces[i] = rand64 () | 1;
}

/*------------------------------------------------------------------------*/

// String functions.

static char * duplicate_string (const char * str) {
  if (!str) return 0;
  size_t bytes = strlen (str) + 1;
  char * res = allocate (bytes);
  assert(res);
  strcpy (res, str);
  return res;
}

static void deallocate_string (char * str) {
  deallocate (str, strlen (str) + 1);
}

static uint64_t hash_string (const char * str) {
  uint64_t res = 0;
  size_t i = 0;
  for (const char * p = str; *p; p++) {
    res += *p;
    res *= nonces[i++];
    if (i == num_nonces) i = 0;
  }
  return res;
}

/*------------------------------------------------------------------------*/

// Variables are kept canonical using a global hash table similar to a
// symbol table in an ordinary compiler.

typedef struct Variable Variable;

struct Variable {
  char * name;			// variable name
  uint64_t hash;		// saved hash value
  Variable * next;		// hash collision chain link
  int count;
  uint64_t level;

};

static uint64_t num_variables;
static uint64_t size_variables;
static Variable ** variable_table;

static void enlarge_variables () {
  uint64_t new_size_variables = size_variables ? 2*size_variables : 1;
  Variable ** new_variable_table;
  ALLOCATE (new_variable_table, new_size_variables);
  for (uint64_t i = 0; i < size_variables; i++) {
    for (Variable * v = variable_table[i], * n; v; v = n) {
      uint64_t h = v->hash & (new_size_variables - 1);
      n = v->next;
      v->next = new_variable_table[h];
      new_variable_table[h] = v;
    }
  }
  DEALLOCATE (variable_table, size_variables);
  variable_table = new_variable_table;
  size_variables = new_size_variables;
}

static int is_valid_variable_letter (char ch) {
  if (ch == '_') return 1;
  if ('0' <= ch && ch <= '9') return 1;
  if ('a' <= ch && ch <= 'z') return 1;
  if ('A' <= ch && ch <= 'Z') return 1;
  return 0;
}

static int is_valid_variable_first_letter (char ch) {
  if (ch == '_') return 1;
  if ('a' <= ch && ch <= 'z') return 1;
  if ('A' <= ch && ch <= 'Z') return 1;
  return 0;
}

static int is_valid_delete_token (const char * name) {
  if (!name) return 0;
  if (name[0] != 'd') return 0;
  if (name[1]) return 0;
  return 1;
}

#ifndef NDEBUG

static int is_valid_variable_name (const char * name) {
  if (!name) return 0;
  if (!is_valid_variable_first_letter (name[0])) return 0;
  for (const char * p = name + 1; *p; p++)
    if (!is_valid_variable_letter (*p)) return 0;
  return 1;
}

#endif

static Variable * new_variable (const char * name, int not_new_allowed) {
  assert (is_valid_variable_name (name));
  if (num_variables == size_variables) enlarge_variables ();
  const uint64_t hash = hash_string (name);
  const uint64_t h = hash & (size_variables - 1);
  Variable ** p, * res;
  for (p = variable_table + h;
       (res = *p) && strcmp (res->name, name);
       p = &res->next)
    ;
  if (!res && not_new_allowed){
    fprintf (stderr, "*** 'pacheck' error: Variable '%s' is not contained in ideal.\n", name);
    fflush (stderr);
    exit (1);
  }
  if (!res) {
    *p = res = allocate (sizeof *res);
    res->name = duplicate_string (name);
    res->hash = hash;
    res->next = 0;
    //res->level = max_level++;
    res->count = 1;
    res->level = ++num_variables;
  } else {
    res->count++;
  }
  return res;
}

static void deallocate_variables () {
  for (uint64_t i = 0; i < size_variables; i++) {
    for (Variable * v = variable_table[i], * n; v; v = n) {
      n = v->next;
      deallocate_string (v->name);
      deallocate (v, sizeof *v);
    }
  }
  DEALLOCATE (variable_table, size_variables);
}

static void print_variable (Variable * v, FILE * file) {
  fputs (v->name, file);
}


static int cmp_variable_strcmp (Variable * a, Variable * b) {
  if(a == b) return 0;
  return strcmp(a->name, b->name);
}

static int cmp_variable_strcmp_rev (Variable * a, Variable * b) {
  if(a == b) return 0;
  return -1*strcmp(a->name, b->name);
}

static int cmp_variable_level (Variable * a, Variable * b) {
  if(a == b) return 0;
  if(a->level < b->level) return 1;
  return -1;
}

static int cmp_variable_level_rev (Variable * a, Variable * b) {
  if(a == b) return 0;
  if(a->level > b->level) return 1;
  return -1;
}

static int cmp_variable(Variable *a, Variable*b){
  if (sort == 1) return cmp_variable_strcmp_rev(a,b);
  else if (sort == 2) return cmp_variable_level(a,b);
  else if (sort == 3) return cmp_variable_level_rev(a,b);
  else return cmp_variable_strcmp(a,b);
}


/*------------------------------------------------------------------------*/
// Routines to manipulate powers of variables.

typedef struct Power Power;

// These powers are just pairs of variables and exponents and since
// variables are never deleted and exponents are just machine words we do
// not need any heap manipulation here.

struct Power {
  Variable * variable;
  uint64_t exponent;
};

static Power new_power (Variable * variable, uint64_t exponent) {
  Power res = { variable, exponent };
  return res;
}

static void print_power (Power p, FILE * file) {
  print_variable (p.variable, file);
  if (p.exponent != 1) {
    fputc ('^', file);
    fprintf (file, "%" PRIu64, p.exponent);
  }
}

static int cmp_powers (const Power * a, const Power * b) {
  return cmp_variable (a->variable, b->variable);
}

/*------------------------------------------------------------------------*/

// We provide a global stack of powers for sorting.

static uint64_t num_powers;
static uint64_t size_powers;
static Power * powers;

static void enlarge_powers () {
  size_t new_size_powers = size_powers ? 2*size_powers : 1;
  REALLOCATE (powers, size_powers, new_size_powers);
  size_powers = new_size_powers;
}

static void push_power (Power p) {
  if (size_powers == num_powers) enlarge_powers ();
  powers[num_powers++] = p;
}

static void clear_powers () { num_powers = 0; }

static void deallocate_powers () { DEALLOCATE (powers, size_powers); }

// Sort powers according to the variable order.
static void sort_powers () {
  qsort (powers, num_powers, sizeof *powers,
    (int(*)(const void *, const void *)) cmp_powers);
}

// Merge powers on the stack and flush out those with zero exponent too.

static void merge_powers () {
  Power * a = 0;
  size_t i = 0;
  for (size_t j = 0; j < num_powers; j++) {
    Power * b = powers + j;
    if (!b->exponent) continue;
    if (a && a->variable == b->variable) {
      if (UINT64_MAX - a->exponent < b->exponent)
	die ("maximum exponent range exhausted while merging powers");
      if(exponents) a->exponent += b->exponent;
    } else {
      if (a) assert (cmp_variable (a->variable, b->variable) < 0);
      a = powers + i;
      *a = *b;
      i++;
    }
  }
  num_powers = i;
}

/*------------------------------------------------------------------------*/

// Terms are sorted products of powers of variables.

// They are in principle stored as sorted singly linked lists (through the
// 'rest' pointer) but all lists and suffixes are stored in a hash table to
// make them canonical.  In contrast to variables, which are assumed to be
// live much longer, we support deletion of terms through reference
// counting.  This should save memory and eventually will also allow to
// properly support deletion lines in proofs.

typedef struct Term Term;

struct Term {
  Variable * variable;
  uint64_t exponent;	// non-zero exponent
  Term * rest;	// singly linked list
  uint64_t degree;	// degree of rest + exponent
  uint64_t ref;		// reference counter
  uint64_t hash;	// saved hash value
  Term * next;	// collision chain
};

// Hash table to canonical store terms.

static uint64_t size_terms;
static uint64_t current_terms;
static Term ** term_table;

static void enlarge_terms () {
  uint64_t new_size_terms = size_terms ? 2*size_terms : 1;
  Term ** new_term_table;
  ALLOCATE (new_term_table, new_size_terms);
  for (uint64_t i = 0; i < size_terms; i++) {
    for (Term * m = term_table[i], * n; m; m = n) {
      uint64_t h = m->hash & (new_size_terms - 1);
      n = m->next;
      m->next = new_term_table[h];
      new_term_table[h] = m;
    }
  }
  DEALLOCATE (term_table, size_terms);
  term_table = new_term_table;
  size_terms = new_size_terms;
}


static uint64_t
compute_hash_term (Variable * variable,
                       uint64_t exponent, Term * rest) {
  assert (variable);
  uint64_t res = rest ? rest->hash : 0;
  res *= nonces[0];
  res += exponent;
  res *= nonces[1];
  res += variable->hash;
  res *= nonces[2];
  return res;
}

static void print_term (Term * m, FILE * file) {
  if (!m) fputc ('1', file);
  else {
    Term * n = m;
    while (n) {
      if (n != m) fputc ('*', file);
      print_power (new_power (n->variable, n->exponent), file);
      n = n->rest;
    }
  }
}

static int
match_term (Term * m,
                Variable * variable, uint64_t exponent, Term * rest) {
  if (m->variable != variable) return 0;
  if (m->exponent != exponent) return 0;
  if (m->rest != rest) return 0;
  return 1;
}

static Term * copy_term (Term * m) {
  if (!m) return m;
  assert (m->ref > 0);
  m->ref++;
  assert (m->ref);
  return m;
}

// Statistic counters for terms.

static uint64_t max_terms;
static uint64_t total_terms;
static uint64_t hits_terms;
static uint64_t searched_terms;
static uint64_t collisions_terms;
static uint64_t max_degree;

// First low-level allocation and deallocation of terms.

static Term *
allocate_term (Variable * variable,
                   uint64_t exponent, Term * rest) {
  Term * res = allocate (sizeof *res);
  res->variable = variable;
  res->exponent = exponent;
  res->rest = copy_term (rest);
  if (!rest) res->degree = exponent;
  else if (UINT64_MAX - exponent < rest->degree)
    die ("maximum degree exhausted");
  else res->degree = exponent + rest->degree;
  if (res->degree > max_degree) max_degree = res->degree;
  total_terms++;
  current_terms++;
  if (current_terms > max_terms) max_terms = current_terms;
  return res;
}

static void deallocate_term (Term * m) {
  assert (current_terms);
  current_terms--;
  deallocate (m, sizeof *m);
}

static void deallocate_terms () {
  for (uint64_t i = 0; i < size_terms; i++) {
    for (Term * m = term_table[i], *n; m; m = n) {
      n = m->next;
      deallocate_term (m);
    }
  }
  DEALLOCATE (term_table, size_terms);
}


// Then searching and adding a term extended by one power.


static Term *
new_term (Variable * variable, uint64_t exponent, Term * rest) {
  if (!exponent) return copy_term (rest);
  if (rest) assert (cmp_variable (variable, rest->variable) < 0);
  if (current_terms == size_terms) enlarge_terms ();
  const uint64_t hash = compute_hash_term (variable, exponent, rest);
  const uint64_t h = hash & (size_terms - 1);
  searched_terms++;
  Term * res;
  for (res = term_table[h];
       res && !match_term (res, variable, exponent, rest);
       res = res->next) {
    collisions_terms++;
  }
  if (res) {
    hits_terms++;
    res->ref++;
  } else {
    res = allocate_term (variable, exponent, rest);
    res->ref = 1;
    res->hash = hash;
    res->next = term_table[h];
    term_table[h] = res;
  }
  return res;
}

// Decrements the reference count of a term, and actually deletes a
// term if its reference count goes to zero.  In this case it also
// removes it from the hash table and applies the same procedure to the
// suffix 'rest'.

static void delete_term (Term * m) {
  while (m) {
    assert (m->ref > 0);
    if (--m->ref > 0) break;
    Term * rest = m->rest;
    const uint64_t h = m->hash & (size_terms - 1);
    Term ** p = term_table + h, * n;
    while ((n = *p) != m) assert (n), p = &n->next;
    *p = n->next;
    deallocate_term (m);
    m = rest;
  }
}


static Term * multiply_terms (Term * a, Term * b) {
  if (!a) return copy_term (b);
  if (!b) return copy_term (a);
  const int cmp = cmp_variable (a->variable, b->variable);
  Term * arest, * brest;
  Variable * variable;
  uint64_t exponent;
  if (cmp < 0) {
    arest = a->rest;
    brest = b;
    exponent = a->exponent;
    variable = a->variable;
  } else if (cmp > 0) {
    arest = a;
    brest = b->rest;
    exponent = b->exponent;
    variable = b->variable;
  } else {
    assert (a->variable == b->variable);
    arest = a->rest;
    brest = b->rest;
    if (UINT64_MAX - a->exponent < b->exponent)
      die ("maximum exponent range exhausted while multiplying terms");
    if(!exponents) exponent = a->exponent;
    else exponent = a->exponent + b->exponent;
    variable = a->variable;
  }
  Term * rest = multiply_terms (arest, brest);
  Term * res = new_term (variable, exponent, rest);
  delete_term (rest);
  return res;
}

static int cmp_terms (const Term * a, const Term * b) {
  while (a || b) {
    if (a == b) return 0;
    if (!a && b) return -1;
    if (a && !b) return 1;
    const int res = cmp_variable (a->variable, b->variable);
    if (res) return res;
    assert (a->variable->name == b->variable->name);
    if (a->exponent > b->exponent) return -1;
    if (a->exponent < b->exponent) return 1;
    a = a->rest;
    b = b->rest;
  }
  return 0;
}


static uint64_t hash_term (const Term * a) {
  return a ? a->hash : 0;
}

static uint64_t degree_term (const Term * a) {
  return a ? a->degree : 0;
}

// Building a term from sorted and merges powers.

static Term * build_term () {
  Term * res = 0;
  int i = num_powers;
  while (i > 0) {
    Power p = powers[--i];
    Term * tmp = new_term (p.variable, p.exponent, res);
    delete_term (res);
    res = tmp;
  }
  return res;
}

/*------------------------------------------------------------------------*/

// Monomials are terms with a coefficient (currently only integers).

typedef struct Monomial Monomial;

struct Monomial {
  mpz_t coeff;		// Local coefficient.
  Term * term;		// Canonical term.
  uint64_t ref;
};

static int sign_of_monomial (Monomial * a) { return mpz_sgn(a->coeff) < 0 ? -1 : 1; }

static int is_zero_monomial (Monomial * a) { return mpz_cmp_si(a->coeff, 0) == 0;}

static int is_one_monomial (Monomial * a) {
  if (a->term) return 0;
  return mpz_cmp_si(a->coeff, 1) == 0;
}


static Monomial * allocate_monomial () {
  Monomial * res = allocate (sizeof *res);
  res->ref = 1;
  return res;
}

static Monomial * new_monomial (mpz_t coeff, Term * term) {
  Monomial * res = allocate_monomial ();
  mpz_init(res->coeff);
  mpz_set(res->coeff, coeff);
  if (mpz_cmp_si(coeff, 0) == 0) res->term = 0;
  else res->term = copy_term(term);
  return res;
}


static Monomial * copy_monomial (Monomial * a) {
  assert (a->ref > 0);
  a->ref++;
  return a;
}


static void delete_monomial (Monomial * a) {
  assert (a->ref > 0);
  if (--a->ref > 0) return;
  mpz_clear(a->coeff);
  delete_term (a->term);
  deallocate (a, sizeof *a);
}

static Monomial * add_monomials (Monomial * a, Monomial * b) {
  if (is_zero_monomial (a)) return copy_monomial (b);
  if (is_zero_monomial (b)) return copy_monomial (a);
  assert (a->term == b->term);
  Monomial * res = allocate_monomial ();
  mpz_add(res->coeff, a->coeff, b->coeff);
  if (mpz_cmp_si(res->coeff, 0) == 0) res->term = 0;
  else res->term = copy_term(a->term);

  return res;
}

static Monomial * multiply_monomials (Monomial * a, Monomial * b) {
  Monomial * res = allocate_monomial ();
  mpz_mul(res->coeff , a->coeff, b->coeff);
  if (mpz_cmp_si(res->coeff, 0) == 0) res->term = 0;
  else res->term = multiply_terms (a->term, b->term);
  return res;
}


static void print_monomial (Monomial * a, FILE * file) {
  if (!a->term)  mpz_out_str(file, 10, a->coeff);
  else {
    assert (mpz_cmp_si(a->coeff, 0) != 0);
    if (mpz_cmp_si(a->coeff, 1) == 0)
      print_term (a->term, file);
    else if (mpz_cmp_si(a->coeff, -1) == 0)
      fputc ('-', file), print_term (a->term, file);
    else {
      mpz_out_str(file, 10, a->coeff);
      fputc ('*', file);
      print_term (a->term, file);
    }
  }
}

static void print_abs_monomial (Monomial * a, FILE * file) {
  mpz_t aabs;
  mpz_init(aabs);
  mpz_abs(aabs, a->coeff);
  if (!a->term)  mpz_out_str(file, 10, aabs);
  else {
    assert (mpz_cmp_si(a->coeff, 0) != 0);
    if (mpz_cmp_si(a->coeff, 1) == 0 || mpz_cmp_si(a->coeff, -1) == 0)
      print_term (a->term, file);
    else {
      mpz_out_str(file, 10, aabs);
      fputc ('*', file);
      print_term (a->term, file);
    }
  }
  mpz_clear(aabs);
}

static int cmp_monomials (Monomial * a, Monomial * b) {
  const int res = cmp_terms (a->term, b->term);
  if (res) return res;
  return mpz_cmp (a->coeff, b->coeff);
}


static uint64_t hash_monomial (Monomial * a) {
  char * str = mpz_get_str(NULL, 10, a->coeff);
  uint64_t res = hash_string (str);
  res *= nonces[0];
  res += hash_term (a->term);
  res *= nonces[1];
  free(str);
  return res;
}

/*------------------------------------------------------------------------*/

// Stack to sort and merge monomials.

static size_t num_monomials;
static size_t size_monomials;
static Monomial ** monomials;

static void enlarge_monomials () {
  size_t new_size_monomials = size_monomials ? 2*size_monomials : 1;
  REALLOCATE (monomials, size_monomials, new_size_monomials);
  size_monomials = new_size_monomials;
}

static void push_monomial (Monomial * t) {
  if (size_monomials == num_monomials) enlarge_monomials ();
  monomials[num_monomials++] = t; //copy_monomial (t);
}

static void clear_monomials () {
  for (size_t i = 0; i < num_monomials; i++)
    delete_monomial (monomials[i]);
  num_monomials = 0;
}

static void deallocate_monomials () { DEALLOCATE (monomials, size_monomials); }

static int cmp_monomials_for_qsort (const void * p, const void * q) {
  Monomial * a = *(Monomial **) p;
  Monomial * b = *(Monomial **) q;
  return cmp_monomials (a, b);
}

// Sort monomials according to term order.

static void sort_monomials () {
  qsort (monomials, num_monomials, sizeof *monomials, cmp_monomials_for_qsort);
}

// Merge monomials with the same terms and flush zero monomials.

static void merge_monomials () {
  Monomial * a = 0;
  size_t i = 0;
  for (size_t j = 0; j < num_monomials; j++) {
    Monomial * b = monomials[j];
    if (is_zero_monomial (b)) delete_monomial (b);
    else if (a && a->term == b->term) {
      Monomial * c = add_monomials (a, b);
      assert (i > 0);
      assert (monomials[i-1] == a);
      delete_monomial (a);
      delete_monomial (b);
      monomials[i-1] = c;
      a = c;
    } else {
      if (a) assert (cmp_monomials (a, b) < 0);
      monomials[i++] = b;
      a = b;
    }
  }
  num_monomials = i;
}

static uint64_t degree_monomial (Monomial * monomial) {
  return degree_term (monomial->term);
}

/*------------------------------------------------------------------------*/

typedef struct Polynomial Polynomial;

struct Polynomial {
  Monomial * monomial;
  Polynomial * rest;
};

static Polynomial * target  = 0;



static Polynomial * new_polynomial (Monomial * monomial,  Polynomial * rest) {
  if (is_zero_monomial (monomial)) return rest;
  if (rest) assert (cmp_monomials (monomial, rest->monomial) < 0);
  Polynomial * res = allocate (sizeof *res);
  res->monomial = copy_monomial (monomial);
  res->rest = rest;
  return res;
}



static int is_one_poly (Polynomial * p) {
  if (!p) return 0;
  return !p->rest && is_one_monomial (p->monomial);
}

static void delete_polynomial (Polynomial * a) {
  while (a) {
    Polynomial * rest = a->rest;
    delete_monomial (a->monomial);
    deallocate (a, sizeof *a);
    a = rest;
  }
}

static int sparse_polynomial_printing = 0;

static void print_polynomial (Polynomial * p, FILE * file) {
  if (!p) fputc ('0', file);
  else {
    print_monomial (p->monomial, file);
    for (Polynomial * q = p->rest; q; q = q->rest) {
      int sign = sign_of_monomial (q->monomial);
      if (sparse_polynomial_printing) fputc (' ', file);
      fputc (sign < 0 ? '-' : '+', file);
      if (sparse_polynomial_printing) fputc (' ', file);
      print_abs_monomial (q->monomial, file);
    }
  }
}

// Building a polynomial from sorted and merged monomials.

static Polynomial * build_polynomial () {
  Polynomial * res = 0;
  int i = num_monomials;
  while (i > 0)
    res = new_polynomial (monomials[--i], res);
  return res;
}


static Polynomial * negate_poly(Polynomial * p1){
  Polynomial * res = p1;

  while(res){
    mpz_mul_si(res->monomial->coeff, res->monomial->coeff, -1);
    res = res->rest;
  }

  return p1;
}

static Polynomial * add_polynomials_new (Polynomial * p1, Polynomial * p2) {
  assert(!num_monomials);

  while(p1 && p2){
    if(cmp_terms(p1->monomial->term, p2->monomial->term) < 0){
      push_monomial(copy_monomial(p1->monomial));
      p1 = p1->rest;
    }
    else if(cmp_terms(p1->monomial->term, p2->monomial->term) > 0){
      push_monomial(copy_monomial(p2->monomial));
      p2 = p2->rest;
    }
    else{
      mpz_t tmp;
      mpz_init(tmp);
      mpz_add(tmp, p1->monomial->coeff, p2->monomial->coeff);

      if(mpz_cmp_si(tmp, 0) != 0){
        Term * t = p1->monomial->term;
        Monomial * m = new_monomial(tmp, t);
        push_monomial(m);
      }
      mpz_clear (tmp);
      p1 = p1->rest;
      p2 = p2->rest;
    }
  }

  while(p1){
    push_monomial(copy_monomial(p1->monomial));
    p1 = p1->rest;
  }
  while(p2){
    push_monomial(copy_monomial(p2->monomial));
    p2 = p2->rest;
  }

  Polynomial * p = build_polynomial();
  clear_monomials ();
  return p;
}

static Polynomial * add_polynomials_old (Polynomial * a, Polynomial * b) {
  for (Polynomial * p = a; p; p = p->rest) push_monomial (copy_monomial(p->monomial));
  for (Polynomial * q = b; q; q = q->rest) push_monomial (copy_monomial(q->monomial));
  sort_monomials ();
  merge_monomials ();
  Polynomial * res = build_polynomial ();
  clear_monomials ();

  return res;
}

static Polynomial * add_polynomials (Polynomial * a, Polynomial * b) {
  if(add_new == 1) return add_polynomials_new(a,b);
  else return add_polynomials_old(a,b);
}

static Polynomial * multiply_polynomials (Polynomial * a, Polynomial * b) {
  for (Polynomial * p = a; p; p = p->rest) {
    for (Polynomial * q = b; q; q = q->rest) {
      Monomial * t = multiply_monomials (p->monomial, q->monomial);
      push_monomial (t);
    }
  }
  sort_monomials ();
  merge_monomials ();
  Polynomial * res = build_polynomial ();
  clear_monomials ();
  return res;
}



static int cmp_polynomials (Polynomial * a, Polynomial * b) {
  const Polynomial * p = a;
  const Polynomial * q = b;
  while (p && q) {
    int res = cmp_monomials (p->monomial, q->monomial);
    if (res) return res;
    p = p->rest;
    q = q->rest;
  }
  if (!p && q) return -1;
  if (p && !q) return 1;
  return 0;
}

static int is_target_polynomial (Polynomial * p) {
  return !cmp_polynomials(target, p);
}


static uint64_t hash_polynomial (Polynomial * a) {
  size_t i = 0;
  uint64_t res = 0;
  for (Polynomial * p = a; p; p = p->rest) {
    res += hash_monomial (p->monomial);
    res *= nonces[i];
    if (++i == num_nonces) i = 0;
  }
  return res;
}


static uint64_t size_polynomial (Polynomial * a) {
  uint64_t res = 0;
  while (a) res++, a = a->rest;
  return res;
}

static uint64_t degree_polynomial (Polynomial * a) {
  uint64_t res = 0;
  while (a) {
    uint64_t tmp = degree_monomial (a->monomial);
    if (tmp > res) res = tmp;
    a = a->rest;
  }
  return res;
}

/*------------------------------------------------------------------------*/

static size_t size_buffer;
static size_t num_buffer;
static char * buffer;

static void enlarge_buffer () {
  size_t new_size_buffer = size_buffer ? 2*size_buffer : 1;
  buffer = reallocate (buffer, size_buffer, new_size_buffer);
  size_buffer = new_size_buffer;
}

static void push_buffer (char ch) {
  if (size_buffer == num_buffer) enlarge_buffer ();
  buffer[num_buffer++] = ch;
}

static void clear_buffer () { num_buffer = 0; }

static void deallocate_buffer () { DEALLOCATE (buffer, size_buffer); }

/*------------------------------------------------------------------------*/

// Character reading routines.

static uint64_t lineno;
static uint64_t columno;
static uint64_t charno;
static const char * parse_file_name;
static FILE * parse_file;
static int close_parse_file;
static int saved_char;
static int char_saved;
static uint64_t last_line_length;

static int next_char () {
  int res;
  if (char_saved) {
    res = saved_char;
    char_saved = 0;
  } else {
#ifdef HAVEUNLOCKEDIO
    res = getc_unlocked (parse_file);
#else
    res = getc (parse_file);
#endif
  }
  if (res == '\n') {
    last_line_length = columno;
    columno = 0;
    lineno++;
  } else if (res != EOF) {
    columno++;
  }
  if (res != EOF) charno++;
  return res;
}

static void prev_char (int ch) {
  assert (!char_saved);
  if (ch == '\n') {
    columno = last_line_length;
    assert (lineno > 0);
    lineno--;
  } else if (ch != EOF) {
    assert (charno > 0);
    charno--;
    assert (columno > 0);
    columno--;
  }
  saved_char = ch;
  char_saved = 1;
}

/*------------------------------------------------------------------------*/

// Scanner.

typedef const char * Token;

static Token END_OF_FILE_TOKEN = "end-of-file";
static Token MINUS_TOKEN       = "minus operator";
static Token PLUS_TOKEN	       = "addition operator";
static Token MULTIPLY_TOKEN    = "multiplication operator";
static Token POWER_TOKEN       = "exponentiation operator";
static Token COLON_TOKEN       = "colon separator";
static Token COMMA_TOKEN       = "comma separator";
static Token SEMICOLON_TOKEN   = "semicolon separator";
static Token NUMBER_TOKEN      = "number";
static Token VARIABLE_TOKEN    = "variable";
static Token EXTENSION_TOKEN   = "equal";

static Token token;
static uint64_t lineno_at_start_of_last_token;
static uint64_t columno_at_start_of_last_token;

static void parse_error (const char * msg, ...) {
  fflush (stdout);
  fprintf (stderr,
    "*** 'pacheck' parse error in '%s'"
    " line %" PRIu64,
    parse_file_name,
    lineno_at_start_of_last_token);
  if (buffer[0] && isprint (buffer[0]))
    fprintf (stderr, " at '%s'", buffer);
  else if (token == END_OF_FILE_TOKEN)
    fputs (" at end-of-file", stderr);
  fputs (": ", stderr);
  va_list ap;
  va_start (ap, msg);
  vfprintf (stderr, msg, ap);
  va_end (ap);
  fputc ('\n', stderr);
  fflush (stderr);
  exit (1);
}

static Token new_token (Token t) {
  push_buffer (0);
  token = t;
  return token;
}

static Token next_token () {
  clear_buffer ();
  for (;;) {
    int ch = next_char ();
    if (ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n')
      continue;
    lineno_at_start_of_last_token = lineno;
    columno_at_start_of_last_token = columno;
    if (ch == EOF) return new_token (END_OF_FILE_TOKEN);
    push_buffer (ch);
    if (ch == '-') return new_token (MINUS_TOKEN);
    if (ch == '+') return new_token (PLUS_TOKEN);
    if (ch == '*') return new_token (MULTIPLY_TOKEN);
    if (ch == '^') return new_token (POWER_TOKEN);
    if (ch == ':') return new_token (COLON_TOKEN);
    if (ch == ',') return new_token (COMMA_TOKEN);
    if (ch == ';') return new_token (SEMICOLON_TOKEN);
    if (ch == '=') return new_token (EXTENSION_TOKEN);
    if (ch == '{') return next_token();
    if (ch == '}') return next_token();
    if ('0' <= ch && ch <= '9') {
      while ('0' <= (ch = next_char ()) && ch <= '9')
      	push_buffer (ch);
      prev_char (ch);
      return new_token (NUMBER_TOKEN);
    }
    if (is_valid_variable_first_letter (ch)) {
      while (is_valid_variable_letter (ch = next_char ()))
	       push_buffer (ch);
      prev_char (ch);
      return new_token (VARIABLE_TOKEN);
    }
    if (isprint (ch)) parse_error ("invalid character");
    else parse_error ("invalid character code 0x%02x", ch);
  }
}

static int is_separator_token (Token t) {
  if (t == COLON_TOKEN) return 1;
  if (t == COMMA_TOKEN) return 1;
  if (t == SEMICOLON_TOKEN) return 1;
  return 0;
}

/*------------------------------------------------------------------------*/

// Parser for polynomials.



static Variable * parse_variable (int not_new_allowed) {
  Variable * res = new_variable (buffer, not_new_allowed);
  next_token ();
  return res;
}

static uint64_t parse_exponent () {
  uint64_t res = 0;
  for (const char * p = buffer; *p; p++) {
    if (UINT64_MAX/10 < res)
      parse_error ("invalid exponent");
    res *= 10;
    int ch = *p;
    assert ('0' <= ch);
    assert (ch <= '9');
    uint64_t digit = ch - '0';
    if (res - digit < res)
      parse_error ("invalid exponent");
    res += digit;
  }
  next_token ();
  return res;
}

static Term * parse_term (int not_new_allowed) {
  assert (!num_powers);
  while (token == VARIABLE_TOKEN) {
    Variable * variable = parse_variable (not_new_allowed);
    if(not_new_allowed && !variable) return 0;
    uint64_t exponent;
    if (token == POWER_TOKEN) {
      if (!exponents) parse_error ("turn on exponents mode with '--exponents'");
      next_token ();
      if (token != NUMBER_TOKEN)
	      parse_error ("exponent missing after '^'");
      exponent = parse_exponent ();
    } else exponent = 1;
    Power p = new_power (variable, exponent);
    push_power (p);
    if (token == MULTIPLY_TOKEN) next_token ();
  }

  sort_powers ();
  merge_powers ();
  Term * res = build_term ();
  clear_powers ();
  return res;
}

static Monomial * parse_monomial (int sign, int not_new_allowed) {
  mpz_t number;
  mpz_init(number);

  if (token == NUMBER_TOKEN) {
    mpz_set_str(number, buffer, 10);
    next_token();
  }
  else if (token == VARIABLE_TOKEN) mpz_set_ui (number, 1);
  else parse_error ("expected monomial");
  if (sign < 0) {
    mpz_mul_si(number, number, -1);
  }
  if (token == MULTIPLY_TOKEN) next_token ();
  Term * term = parse_term (not_new_allowed);

  Monomial * res = new_monomial (number, term);
  delete_term (term);
  mpz_clear (number);
  return res;
}

static Polynomial * parse_polynomial (int not_new_allowed) {

  int sign;
  if (token == MINUS_TOKEN) {
    next_token ();
    if (token == NUMBER_TOKEN && buffer[0] == '0')
      parse_error ("unexpected '0' after '-'");
    sign = -1;
  } else sign = 1;
  assert (!num_monomials);
  for (;;) {
    Monomial * monomial = parse_monomial (sign, not_new_allowed);
    push_monomial (monomial);
    if (is_separator_token (token)) break;
    if (token == MINUS_TOKEN) {
      sign = -1;
      next_token ();
    } else if (token == PLUS_TOKEN) {
      sign = 1;
      next_token ();
    } else parse_error ("unexpected %s", token);
  }
  sort_monomials ();
  merge_monomials ();
  Polynomial * res = build_polynomial ();
  clear_monomials ();
  return res;
}


static uint64_t parse_index () {
  if (token != NUMBER_TOKEN) parse_error ("unexpected token");

  char * ptr;

  int index = strtol(buffer, &ptr, 10 );
  next_token();

  return index;
}

/*------------------------------------------------------------------------*/

typedef const char * Rule;

static Rule ORIGINAL_RULE       = "original polynomial";
static Rule EXTENSION_RULE      = "extension polynomial";
static Rule ADDITION_RULE       = "polynomial addition";
static Rule MULTIPLICATION_RULE = "polynomial multiplication";

typedef struct Inference Inference;

struct Inference {
  uint64_t id;				// unique
  uint64_t line;			// start line in file
  Polynomial * conclusion;		// produced / added polynomial
  Inference * chronological_next;	// next doubly linked list
  Inference * chronological_prev;	// prev doubly linked list
  Inference * collision_chain_link;	// for hash table
  uint64_t hash;			// saved for faster enlargement
};

// inferences hash table with multi-set semantics
// (chains chronologically sorted thus first inference found first)

static uint64_t max_num_inferences;
static uint64_t num_inferences;
static uint64_t num_inference_rules;
static uint64_t size_inferences;
static Inference ** inference_table;

// inferences chronological doubly linked list

static Inference * first_inference;
static Inference * last_inference;

// statistics for inferences

static uint64_t original_inferences;
static uint64_t addition_inferences;
static uint64_t multiplication_inferences;
static uint64_t deletion_inferences;
static uint64_t extension_inferences;
static uint64_t rule_inferences;
static uint64_t searched_inferences;
static uint64_t collisions_inferences;
static uint64_t target_polynomial_inferences;
static uint64_t non_zero_constant_polynomial_inferences;

static void enlarge_inferences () {
  uint64_t new_size_inferences = size_inferences ? 2*size_inferences : 1;
  Inference ** new_inference_table;
  ALLOCATE (new_inference_table, new_size_inferences);
  for (Inference * p = last_inference; p; p = p->chronological_prev) {
    uint64_t h = p->hash & (new_size_inferences - 1);
    Inference * m = new_inference_table[h];
    p->collision_chain_link = m;
    new_inference_table[h] = p;
  }
  DEALLOCATE (inference_table, size_inferences);
  inference_table = new_inference_table;
  size_inferences = new_size_inferences;
}

static Inference *
allocate_inference (Rule rule,
		    uint64_t line,
		    Polynomial * conclusion,
		    uint64_t hash,
        int index)
{
  Inference * res = allocate (sizeof *res);
  res->id = index;
  num_inferences++;
  res->line = line;
  res->conclusion = conclusion;
  if (!last_inference) first_inference = res;
  else last_inference->chronological_next = res;
  res->chronological_prev = last_inference;
  last_inference = res;
  res->chronological_next = 0;
  res->collision_chain_link = 0;
  res->hash = hash;
  if (rule == ORIGINAL_RULE) original_inferences++;
  if (rule == ADDITION_RULE)
    addition_inferences++, rule_inferences++;
  if (rule == MULTIPLICATION_RULE)
    multiplication_inferences++, rule_inferences++;
  if (rule == EXTENSION_RULE)
    extension_inferences++, rule_inferences++;
  if (check_target && is_target_polynomial (conclusion)){
    if (rule == ORIGINAL_RULE){
      fprintf (stdout, "\n");
      msg("WARNING: target polynomial is given as original polynomial.");
      msg("Proof rules are obsolet, but will be checked anyway!\n");
    }
    target_polynomial_inferences++;
  }

  if (is_one_poly (conclusion))
    non_zero_constant_polynomial_inferences++;
  max_num_inferences++;
  return res;
}

// Find first inference with the same polynomial.

static Inference * find_inference (Polynomial * p) {
  if (!size_inferences) return 0;
  const uint64_t hash = hash_polynomial (p);
  const uint64_t h = hash & (size_inferences - 1);
  searched_inferences++;
  Inference * res;
  for (res = inference_table[h];
       res && cmp_polynomials (res->conclusion, p);
       res = res->collision_chain_link)
    collisions_inferences++;
  return res;
}

static Inference * find_inference_index (uint64_t index) {

  if (!size_inferences) return 0;
  const uint64_t hash = index;
  const uint64_t h = hash & (size_inferences - 1);

  searched_inferences++;
  Inference * res;
  for (res = inference_table[h];
       res && (res->id != index);
       res = res->collision_chain_link)
    collisions_inferences++;
  return res;
}

// Add inference (even if polynomial was already inferred).

static Inference * new_inference (Rule rule,
	                                uint64_t line, uint64_t index, Polynomial * conclusion)
{
  if (num_inferences == size_inferences) enlarge_inferences ();
  uint64_t hash;
  if (indices) hash = index;
  else hash = hash_polynomial (conclusion);
  const uint64_t h = hash & (size_inferences - 1);
  Inference ** p, * res;
  searched_inferences++;
  for (p = inference_table + h;
       p && (res = *p);
       p = &res->collision_chain_link)
    collisions_inferences++;
  res = allocate_inference (rule, line, conclusion, hash, index);
  if (p) *p = res;
  return res;
}

static void delete_inference_in_run (Inference * i){
  if(first_inference == i){
    first_inference = i->chronological_next;
  }
  if(last_inference == i){
    last_inference = i->chronological_prev;
  }

  if(i->chronological_prev)
        i->chronological_prev->chronological_next = i->chronological_next;

  if(i->chronological_next)
        i->chronological_next->chronological_prev = i->chronological_prev;

  const uint64_t h = i->hash & (size_inferences - 1);
  Inference ** p = inference_table + h, * res;
  while ((res = *p) != i) assert (res), p = &res->collision_chain_link;
  *p = res->collision_chain_link;

  num_inferences--;
  delete_polynomial (i->conclusion);
  deallocate (i, sizeof *i);
}


static void delete_inference_in_run_index (int index){
  Inference * i = find_inference_index (index);
  if (!i){
    fprintf (stdout, "\n");
    msg("WARNING: cannot delete inference with index %i - inference does not exist\n", index);
    return;
  }
  delete_inference_in_run(i);

}

static void delete_inference (Inference * i) {
  delete_polynomial (i->conclusion);
  deallocate (i, sizeof *i);
}

static void delete_inferences () {
  for (Inference * p = first_inference, * n; p; p = n) {
    n = p->chronological_next;
    delete_inference (p);
  }
  DEALLOCATE (inference_table, size_inferences);
}

/*------------------------------------------------------------------------*/

// Proof statistics.

static uint64_t size_proof;
static uint64_t degree_proof;
static uint64_t length_proof;

/*------------------------------------------------------------------------*/

// Original polynomial inference parsing.

static void init_parsing (const char * file_name) {
  if (file_name) {
    parse_file_name = file_name;
    parse_file = fopen (file_name, "r");
    if (!parse_file)
      die ("can not open '%s' for reading", file_name);
    close_parse_file = 1;
  } else {
    parse_file = stdin;
    parse_file_name = "<stdin>";
    close_parse_file = 0;
  }
  lineno = 1;
  columno = 0;
  charno = 0;
}

static void reset_parsing () {
  if (close_parse_file && fclose (parse_file))
    die ("failed to close '%s'", parse_file_name);
  msg ("read %" PRIu64 " bytes from '%s'", charno, parse_file_name);
}

static void update_statistics_for_newly_added_polynomial (Polynomial * p) {
    const uint64_t size = size_polynomial (p);
    const uint64_t degree = degree_polynomial (p);
    length_proof++;
    size_proof += size;
    if (degree > degree_proof) degree_proof = degree;
}

static void parse_original_polynomial () {
  uint64_t line = lineno_at_start_of_last_token;

  if(indices && token != NUMBER_TOKEN) parse_error("no index detected (try '-h')");

  int index = -1;
  if(indices){
    index = parse_index();
    if (find_inference_index(index)) parse_error("index %i already exists", index);
  }

  Polynomial * p = parse_polynomial (0);
  if (!is_separator_token (token)) parse_error("unexpected %s token", token);

  update_statistics_for_newly_added_polynomial (p);
  if(indices) new_inference (ORIGINAL_RULE, line, index, p);
  else new_inference (ORIGINAL_RULE, line, -1, p);
}


/*------------------------------------------------------------------------*/

// Proof rule inference parsing.

static int print_failing_polynomials = 0;

static void
polynomial_not_found (
  int index,
  int p_index,
  Polynomial * p,
  Rule rule,
  uint64_t count,
  const char * which_polynomial,
  uint64_t rule_line,
  uint64_t polynomial_line)
{
  fflush (stdout);

  fprintf (stderr, "*** 'pacheck' error in %s rule %" PRIu64 , rule,  count);
  if(index!=-1) fprintf (stderr, " with index %i ",index);
  fprintf (stderr, " in '%s' line %" PRIu64 ": %s polynomial",
        parse_file_name, rule_line, which_polynomial);

  if (rule_line != polynomial_line)
    fprintf (stderr, " line %" PRIu64, polynomial_line);
  fprintf (stderr, " not found");
  if (print_failing_polynomials) {
    fputs (":\n", stderr);
    if(p_index) fprintf (stderr, "%i", p_index);
    if (p) print_polynomial (p, stderr);
  } else fputs (" (use '--print' to print failing polynomials)", stderr);

  if (delete_mode) {
    fputs ("\ndelete mode is ON - try turning it off with '--no-delete'", stderr);
  }

  fputc ('\n', stderr);
  fflush (stderr);
  exit (1);
}

static void
polynomials_do_not_match (
  int index,
  Polynomial * actual,
  Polynomial * expected,
  Rule rule,
  uint64_t count,
  uint64_t rule_line,
  uint64_t polynomial_line)
{
  fflush (stdout);

  fprintf (stderr, "*** 'pacheck' error in %s rule %" PRIu64 , rule,  count);
  if(index) fprintf (stderr, " with index %i ",index);

  fprintf (stderr,
    " in '%s' line %" PRIu64 ": conclusion polynomial",
     parse_file_name, rule_line);
  if (rule_line != polynomial_line)
    fprintf (stderr, " line %" PRIu64, polynomial_line);
  if (print_failing_polynomials) {
    fputs (":\n", stderr);
    print_polynomial (actual, stderr);
    fputs ("\ndoes not match expected result:\n", stderr);
    print_polynomial (expected, stderr);
  } else fputs (" does not match expected result"
                " (use '--print' to print failing polynomials)", stderr);
  fputc ('\n', stderr);
  fflush (stderr);
  exit (1);
}

static int check_for_valid_extension_var ( Polynomial * p) {
  if (p->rest) return 0;
  if (mpz_cmp_si(p->monomial->coeff, 1) != 0 ) return 0;

  Term *t = p->monomial->term;
  if (!t) return 0;
  if (t->rest) return 0;
  if (t->variable->count != 1) return 0;

  return 1;
}

static int only_old_var_in_poly ( Polynomial * p, Variable * v) {
  Polynomial * tmp = p;
  while(tmp){
    Term * t = tmp->monomial->term;
    while(t){
      if(t->variable == v) return 0;
      t = t->rest;
    }
    tmp = tmp->rest;
  }
  return 1;
}


static int check_for_valid_extension_poly ( Polynomial * p, Variable * v) {
  if (!only_old_var_in_poly(p, v)) return 0;
  Polynomial * mult = multiply_polynomials(p, p);
  int zero =   (cmp_polynomials (mult, p) == 0);
  delete_polynomial(mult);
  return zero;
}

static void parse_extension_rule (int index) {
  if (exponents) parse_error("extensions are not supported in modus '-e'");
  if (indices && find_inference_index(index)) parse_error("index %i already exists", index);

  next_token();
  uint64_t line = lineno_at_start_of_last_token;
  Polynomial * p1 = parse_polynomial(0);

  if(!check_for_valid_extension_var(p1)) {
    fflush (stdout);
    fprintf (stderr, "*** 'pacheck' error in EXTENSION_RULE rule ");
    if(index) fprintf (stderr, " with index %i ",index);
    fprintf (stderr, " in '%s' line %" PRIu64 ": extension variable is not valid", parse_file_name, line);
    fputc ('\n', stderr);
    fflush (stderr);
    exit (1);

  }
  Variable * ext = p1->monomial->term->variable;

  assert (is_separator_token (token));
  next_token ();

  Polynomial * p2 = parse_polynomial (1);
  if(!check_for_valid_extension_poly(p2, ext)) {
    fflush (stdout);
    fprintf (stderr, "*** 'pacheck' error in EXTENSION_RULE rule ");
    if(index) fprintf (stderr, " with index %i ",index);
    fprintf (stderr, " in '%s' line %" PRIu64 " is not a valid extension polynomial", parse_file_name, line);
    fputc ('\n', stderr);
    fflush (stderr);
    exit (1);
  }

  if (!is_separator_token (token)) parse_error("unexpected %s token", token);

  p1=negate_poly(p1);
  Polynomial * q = add_polynomials(p1, p2);
  delete_polynomial(p1);
  delete_polynomial(p2);

  update_statistics_for_newly_added_polynomial (q);
  new_inference (EXTENSION_RULE, line, index, q);
}

static void parse_practical_algebraic_calculus_rule (uint64_t checked, int index, int del) {
  if (indices && find_inference_index(index)) parse_error("index %i already exists", index);

  uint64_t rule_line = lineno_at_start_of_last_token;
  Rule rule = 0;
  if (token == PLUS_TOKEN) rule = ADDITION_RULE;
  else if (token == MULTIPLY_TOKEN) rule = MULTIPLICATION_RULE;
  else parse_error ("expected 'd', '+' or '*' instead of %s", token);
  next_token ();

  if (is_separator_token (token)) next_token ();


  uint64_t p0_line = lineno_at_start_of_last_token;

  int64_t p0_index = -1;
  Polynomial * p0 = 0;
  Inference * i0;
  if(indices) p0_index = parse_index();
  else p0 = parse_polynomial (0);

  assert (is_separator_token (token));

  if(indices) i0 = find_inference_index (p0_index);
  else i0 = find_inference(p0);

  if (!i0)
    polynomial_not_found (index, p0_index,  p0, rule, checked + 1, "first", rule_line, p0_line);
  if(p0) delete_polynomial (p0);

  next_token ();
  uint64_t p1_line = lineno_at_start_of_last_token;

  Polynomial * p1 = 0;
  Inference * i1;
  int64_t p1_index = -1;

  if (rule == ADDITION_RULE) {
    if(indices) {
      p1_index = parse_index();
      i1 = find_inference_index (p1_index);
    }
    else {
      p1 = parse_polynomial (0);
      i1 = find_inference (p1);
    }

    if (!i1)
      polynomial_not_found (index, p1_index, p1, rule, checked + 1, "second", rule_line, p1_line);
    if(p1) delete_polynomial (p1);
    p1 = 0;
  } else {
    i1 = 0;
    p1 = parse_polynomial (1);
  }
  assert (is_separator_token (token));

  next_token ();
  uint64_t p2_line = lineno_at_start_of_last_token;
  Polynomial *p2 = parse_polynomial (0);
  assert (is_separator_token (token));

  Polynomial * conclusion;
  if (rule == ADDITION_RULE) {
    assert (i0), assert (i1), assert (!p1);
    conclusion = add_polynomials (i0->conclusion, i1->conclusion);
    if(del && delete_mode && !indices){
      delete_inference_in_run(i0);
      delete_inference_in_run(i1);

    }
  } else {
    assert (i0), assert (!i1); // 'p1' might be empty so zero
    conclusion = multiply_polynomials (i0->conclusion, p1);
    delete_polynomial (p1);
    if(del && delete_mode && !indices){
      delete_inference_in_run(i0);
    }
  }
  if (cmp_polynomials (p2, conclusion))
    polynomials_do_not_match (index, p2, conclusion, rule, checked + 1, rule_line, p2_line);
  delete_polynomial (p2);
  update_statistics_for_newly_added_polynomial (conclusion);
  if(indices) new_inference (rule, rule_line, index, conclusion);
  else new_inference(rule, rule_line, -1, conclusion);

}

/*------------------------------------------------------------------------*/

// Parse whole files.


static void parse_target_polynomial (const char * file_name) {
  init_parsing (file_name);
  next_token();
  msg ("reading target polynomial from '%s'", parse_file_name);
  target = parse_polynomial (0);
  assert (is_separator_token (token));
  if(next_token () != END_OF_FILE_TOKEN)
    die ("unexpected %s token", token);
  reset_parsing ();
}




static void parse_original_polynomials (const char * file_name) {
  init_parsing (file_name);
  msg ("reading original polynomials from '%s'", parse_file_name);
  uint64_t original = 0;
  while (next_token () != END_OF_FILE_TOKEN)
    parse_original_polynomial (), original++;
  msg ("found %" PRIu64 " original polynomials in '%s'",
    original, parse_file_name);
  reset_parsing ();
}

static void
parse_practical_algebraic_calculus_rules (const char * file_name) {
  init_parsing (file_name);
  msg ("reading polynomial algebraic calculus proof from '%s'",
    parse_file_name);
  uint64_t checked = 0, additions = 0, multiplications = 0, extensions = 0;
  int count = 0;

  while (next_token () != END_OF_FILE_TOKEN) {
    int index = -1;
    if(indices){
      if (token != NUMBER_TOKEN) parse_error("no indices given");
      index = parse_index();

      if (token == VARIABLE_TOKEN) {
        if(is_valid_delete_token(buffer)){
          deletion_inferences++;
          if(delete_mode) delete_inference_in_run_index(index);
          if (!is_separator_token (next_token())) parse_error("unexpected %s token", token);
        }
        else die ("unexpected delete token: %s", buffer);
      }
      else if (token == EXTENSION_TOKEN){
        parse_extension_rule(index);
        extensions++;
        num_inference_rules++;
        checked++;
        count++;
      }
      else {
        if (token == PLUS_TOKEN) additions++;
        if (token == MULTIPLY_TOKEN) multiplications++;

        parse_practical_algebraic_calculus_rule (checked, index, 0);
        num_inference_rules++;
        checked++;
        count++;
        if(count == 500 && check_count){
          msg("found and checked %" PRIu64 " inferences so far", checked);
          count = 0;
        }
      }
    } else {
      int del = 0;
      if (token == VARIABLE_TOKEN) {
        if(is_valid_delete_token(buffer)){
          deletion_inferences++;
          del=1;
          next_token();
        }
      }

      if (token == EXTENSION_TOKEN){
        parse_extension_rule(index);
        extensions++;
        num_inference_rules++;
        checked++;
        count++;
      }
      else {
        if (token == PLUS_TOKEN) additions++;
        if (token == MULTIPLY_TOKEN) multiplications++;

        parse_practical_algebraic_calculus_rule (checked, index, del);
        num_inference_rules++;
        checked++;
        count++;
        if(count == 500 && check_count){
          msg("found and checked %" PRIu64 " inferences so far", checked);
          count = 0;
        }
      }
    }
  }
  assert (checked == additions + multiplications + extensions);
  msg ("found and checked %" PRIu64 " inferences in '%s'",
    checked, parse_file_name);
  reset_parsing ();
}

/*------------------------------------------------------------------------*/

static double percent (double a, double b) { return b ? 100.0*a/b : 0; }
static double average (double a, double b) { return b ? a/b : 0; }

/*------------------------------------------------------------------------*/

static void init () {
  init_nonces ();
}

static void deallocate_all () {
  delete_polynomial(target);
  delete_inferences ();
  deallocate_terms ();
  deallocate_monomials ();
  deallocate_powers ();
  deallocate_variables ();
  deallocate_buffer ();
  assert (!current_allocated_bytes);
}

static void reset () {
  deallocate_all ();
}

/*------------------------------------------------------------------------*/



static void print_statistics () {
  msg ("proof length %" PRIu64 " (number of polynomials)", length_proof);
  msg ("proof size %" PRIu64 " (on average %.1f terms per polynomial)",
    size_proof, average (size_proof, length_proof));
  msg ("proof degree %" PRIu64 " (internal maximum degree %" PRIu64 ")",
    degree_proof, max_degree);
  msg ("searched %" PRIu64 " inferences %.1f average collisions",
    searched_inferences,
    average (collisions_inferences, searched_inferences));
  msg ("%" PRIu64 " inferences, %.1f average searches",
    max_num_inferences, average (searched_inferences, max_num_inferences));
  msg ("original inferences %" PRIu64 " (%.0f%% of total rules)",
    original_inferences, percent (original_inferences, max_num_inferences));
  msg ("inference rules %" PRIu64 " (%.0f%% of total rules)",
      num_inference_rules, percent (num_inference_rules, max_num_inferences));
  msg ("addition inference rules %" PRIu64 " (%.0f%% of inference rules)",
    addition_inferences, percent (addition_inferences, num_inference_rules));
  msg ("multiplication inference rules %" PRIu64 " (%.0f%% of inference rules)",
    multiplication_inferences,
    percent (multiplication_inferences, num_inference_rules));
  msg ("extension rules %" PRIu64 " (%.0f%% of inference rules)",
      extension_inferences, percent (extension_inferences, num_inference_rules));
  msg ("deletion inference rules %" PRIu64 " (%.0f%% of total rules)",
      deletion_inferences,
      percent (deletion_inferences, num_inference_rules+original_inferences));
  msg ("maximum %" PRIu64 " of total %" PRIu64 " terms (%.0f%%)",
    max_terms, total_terms,
    percent (max_terms, total_terms));
  msg ("searched %" PRIu64 " terms %.0f%% hits %.1f average collisions",
    searched_terms,
    percent (hits_terms, searched_terms),
    average (collisions_terms, searched_terms));
  msg ("maximum %zu bytes allocated (%.1f MB)",
    max_allocated_bytes, max_allocated_bytes/(double)(1<<20));
#ifdef HAVEGETRUSAGE
  struct rusage u;
  if (getrusage (RUSAGE_SELF, &u)) return;
  size_t s = ((size_t) u.ru_maxrss) << 10;
  msg ("maximum resident set size %zu bytes (%.1f MB)",
    s, s/(double)(1<<20));
  double t = u.ru_utime.tv_sec + 1e-6 * u.ru_utime.tv_usec;
  t += u.ru_stime.tv_sec + 1e-6 * u.ru_stime.tv_usec;
  msg ("process time %.3f seconds", t);
#endif
}


/*------------------------------------------------------------------------*/

// Main routine for stand alone checker.

static void banner () {
  msg ("Pacheck Version " VERSION);
  msg ("Practical Algebraic Calculus Proof Checker");
  msg ("Copyright (C) 2020, Daniela Kaufmann, Johannes Kepler University Linz");
}

int main (int argc, char ** argv) {

  const char * first_file_name = 0;
  const char * second_file_name = 0;
  const char * third_file_name = 0;
  int sort_chosen = 0;

  for (int i = 1; i < argc; i++) {
    if (!strcmp (argv[i], "-h") ||
        !strcmp (argv[i], "--help"))
      fputs (usage, stdout), exit (0);
    else if (!strcmp (argv[i], "-s") ||
             !strcmp (argv[i], "--no-target"))
      check_target = 0;
    else if (!strcmp (argv[i], "-e") ||
             !strcmp (argv[i], "--use-exponents"))
      exponents = 1;
    else if (!strcmp (argv[i], "-d") ||
             !strcmp (argv[i], "--no-delete"))
      delete_mode = 0;
    else if (!strcmp (argv[i], "-i") ||
             !strcmp (argv[i], "--no-indices"))
      indices = 0;
    else if (!strcmp (argv[i], "-v") ||
             !strcmp (argv[i], "--verbose"))
      check_count = 1;
   else if (!strcmp (argv[i], "--print"))
      print_failing_polynomials = 1;
    else if (!strcmp (argv[i], "--sparse"))
      sparse_polynomial_printing = 1;
    else if (!strcmp (argv[i], "-s1")){
      sort = 1;
      sort_chosen++;
    }
    else if (!strcmp (argv[i], "-s2")){
      sort = 2;
      sort_chosen++;
    }
    else if (!strcmp (argv[i], "-s3")){
      sort = 3;
      sort_chosen++;
    }
    else if (!strcmp (argv[i], "--old-add")){
      add_new = 0;
    }
    else if (argv[i][0] == '-')
      die ("invalid command line option '%s' (try '-h')", argv[i]);
    else if (third_file_name)
      die ("too many command line arguments (try '-h')");
    else if (second_file_name)
      third_file_name = argv[i];
    else if (first_file_name) second_file_name = argv[i];
    else first_file_name = argv[i];
  }

  if(!third_file_name) check_target = 0;
  if(sort_chosen > 1) die ("too many variable orderings selected");

  banner ();
  init ();

  if (indices)  msg("compressed mode with indices assumed");
  else msg("expanded mode without indices assumed");

  if (sort == 1) msg("sorting according to reverse strcmp");
  else if (sort == 2) msg("sorting according to input order");
  else if (sort == 3) msg("sorting according to reverse input order");
  else  msg("sorting according to strcmp");


  if (third_file_name && check_target) {
    msg ("checking target enabled");
    parse_target_polynomial (third_file_name);
  }
  if(second_file_name){
    parse_original_polynomials (first_file_name);
    parse_practical_algebraic_calculus_rules (second_file_name);
  } else die ("too few command line arguments (try '-h')");

  if(check_target){
    msg ("found %" PRIu64 " target polynomial inference%s",
      target_polynomial_inferences,
      target_polynomial_inferences == 1 ? "" : "s");
  }

  reset ();
  print_statistics ();


  if (check_target && target_polynomial_inferences) msg ("TARGET CHECKED");
  else if(check_target) msg ("INFERENCES CHECKED - TARGET IS NOT INFERRED");
  else msg("INFERENCES CHECKED");

  if(non_zero_constant_polynomial_inferences) msg("CORRECT REFUTATION");

  return 0;
}
